% vim: set fenc=utf-8 ft=latex encoding=utf-8
% -*- mode: latex; coding: UTF-8; -*-

\newif\ifdraft
\drafttrue

\ifdraft
	\documentclass[conference, draftclsnofoot]{IEEEtran}
	\def\baselinestretch{1}
	\setlength{\marginparwidth}{2cm}
\else
	\documentclass[conferece, final]{IEEEtran}
\fi

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\newcommand{\TheTitle}{Visualizing Release Information of Linux}
\newcommand{\TheAuthors}{Evan Wilde}
\newcommand{\TheEmails}{etcwilde@uvic.ca}
\newcommand{\TheSubject}{Digesting large amounts of commit data}
\newcommand{\TheKeywords}{Linux, git, data structures, tree data structures}

\synctex=1

\usepackage[hyphens]{url}
\urlstyle{same}

\ifdraft
	\usepackage[unicode=true,bookmarks=false,breaklinks=false,
		pdfborder={0 0 0},backref=none,colorlinks=true]{hyperref}

\else
	\usepackage[unicode=true,bookmarks=false,breaklinks=false,
		pdfborder={0 0 0},backref=none,colorlinks=false]{hyperref}
\fi

\usepackage[nospace]{cite}

% Table Support
\usepackage{dcolumn}
\usepackage{longtable}

\usepackage{balance}
\usepackage{placeins}
\usepackage{multirow}

% Extra support
\usepackage{xspace}
\usepackage{caption}

% Fix any bad-hyphenations here
\hyphenation{}

\input{macros.tex}

\begin{document}

\title{\TheTitle}
\author{
\IEEEauthorblockA{\TheAuthors}
\IEEEauthorblockN{Department of Computer Science,
                    University of Victoria, Canada.}
\IEEEauthorblockA{Email: \TheEmails}
}
\maketitle
\begin{abstract}

	With an average of over 900 top-level merges into the Linux kernel per
	release, each containing thousands of commits, maintenance of older
	versions of the kernel becomes nearly impossible. For security,
	performance, and changing hardware, maintainers must understand the
	changes made to current versions of the kernel, and show these changes
	fit into older versions in order to make the necessary merges and
	modifications to the older versions. Current tools provide information
	about repositories through the directed acyclic graph (DAG) which is
	helpful for smaller projects, but with the scale and number of branches
	in the kernel, the DAG becomes overwhelming very quickly.

	In this paper, we present a tool that uses the dataset collected by
	German et al. to build a tool that uses a vine model instead of the
	DAG. This tool is designed to cater to the needs of users looking for a
	top-down approach, or a bottom-up approach to navigating the commit
	information of the kernel.
\end{abstract}

\begin{IEEEkeywords}
\TheKeywords
\end{IEEEkeywords}

\section{Introduction}

Maintainers of older version of the Linux kernel must sift through thousands of
commits with tools that are unable to filter and effectively visualize projects
that are of the scale of the kernel. Tools like gitk provide users with the
full view of the DAG, showing all merges and commits. For smaller projects,
this information is useful to show the relation between various branches. With
larger, modular projects like the Linux Kernel, the DAG becomes a tangled mess
of lines that lose meaning. Github provides a DAG view for most projects, but is
unable to display the DAG of projects as large as the Linux Kernel.

German et al. recorded the metadata of every commit and merge in the Linux git
repository from 2012 to 2015, including data that is not stored by git. We are
able to use this information to generate sets of trees rather than a DAG. The
root node of each tree is the top-level merge performed by Linus, which merges
a given commit into the kernel.

In this paper, we present the design decisions behind a web-based tool that
demonstrates the advantages of using the tree model over the use of a DAG. Our
tool provides information about the location of a given commit in the
respective merge tree, the files edited in the commit or merge, the modules
edited in the commit or merge, and the commit message of a given commit or
merge. The tool allows users various filters, including the release, a keyword
or phrase from a log, the name of the author, or the commit id. The user can
request all the top-level merges containing a commit or merge that matches the
query, or all commits and merges that match the query.

\section{Related Work}

Gitk, Gitg, and other similar git repository visualizing tools display the DAG.
For smaller projects, this model is able to provide meaningful information, but
in large projects like the Linux kernel, the branches become too tangled and
deep to derive any meaning from the DAG.

%% Check for papers if they exist
%% This tool isn't specifically designed for showing Linux

\evantodo{Picture of gitk DAG and github failing}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}


University of Maryland presented a treemap design for displaying all the files
in a given release. This information doesn't provide meaining about what has
changed. The information within the treemap does not provide clear insight on
the meaning of the files, what changes were made, or even the size. The treemap
structure provides information on where in the directory tree the file exists.

%% https://www.cs.umd.edu/hcil/millionvis/Treemap_Visualization_of_the_Linux_Kernel_2_5_33.html
%% Find paper for this maybe?

\evantodo{Picture of visualization}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}


Moghaddam designed a graph showing how various commits in the Kernel were
linked together. This graph doesn't provide a clear picture of what is
happening though, and gives no insight to the hierarchy of the data. It
provides information about who authored the commit, and when the commit was
authored.
%% http://web.uvic.ca/~arasbm/gitVisualizations/linuxRGraph.html
%% Find paper for this maybe?

\evantodo{Picture of graph}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}


\section{Design}

Our primary focus was looking for a way to remove as much information as
possible to narrow the results that we wanted to return. Right now, the largest
set of data that a search could return is the entire set of commits that
pertain to a given release. While this set is massive, it pales in comparison
to every commit and merge generated for all versions of the kernel. From there,
the design is centered around the merge tree. These are all of the commits and
merges that eventually are merged by a top-level merge into the kernel. The
design centers around a vine-shape. The top-level merges form a linked list,
each node being a logical section within the kernel. These sections are defined
by Linus. Within each of these top-level merges is a tree of merges and
commits. The merges form the inner-nodes, and the commits form the leaf-nodes.

\evantodo{Make a vine diagram}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}


Different kinds of users need to be able to use the tool differently.
Some users may be looking for a top-down approach, trying to find the merge
closest to the top-level merge that works with a given set of files. Other uses
may be looking for a bottom-up approach, given a commit, what top-level merge
includes this commit. Other users are interested in what happens in a given
release cycle without any other requirements.

To build an effective tool, we focused on two main areas, the navigation
and presentation.


\subsection{Navigation}

A user is greeted by the search screen. We break the kernel down by release,
limiting the maximum information a user can query to help minimize being
overwhelmed. From there, users can either search by author name, commit id, or
keyword from the log preview. A user may also request the top-level merges that
meet the requirements. If the checkbox is unchecked, a user is able to query
all commits and merges that happened in the selected release cycle. If the box
is checked, the user will get all of the top-level merges in the release cycle
that contain a commit or merge that match the given criteria. If no criteria
are provided and the box is checked, the user will simply be given all
top-level merges for that release cycle. This helps separate the use-cases,
allowing users wanting the bottom-up approach to perform searches, and users
wanting a top-down approach to perform searches.

Once a user has found either the top-level merge or commit that they are
interested in, they should be able to move freely between the commits and
merges in the tree. We use three mechanisms to provide better navigation
through the tree. The tree view, the list tree, and breadcrumbs.

The tree view provides most of the
navigational functionality, allowing users to jump to any commit or merge in
the current tree. The main tree view displays all the commits and merges, the
root is the top-level merge of all the commits and merges in the group. Users
are able to see all commits and merges of all the merges.

\evantodo{Picture of tree}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}

The list tree shows the merges and commits of the current subtree, built as
nested lists of links to the respective commits and merges. The information in
this tree is a subset of the main tree view, providing a method users with a
view of what commits and merges are below the current commit or merge. If the
current position is a commit, the tree will be empty, as commits are leaf
nodes in the tree representation. This is designed for letting users move
quickly down in the tree.

\evantodo{Picture of list tree}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}


The breadcrumbs show the path of merges that are above the current commit or
merge, up to the top-level merge. This allows users a fast way to move up in
the tree.

\evantodo{Picture of breadcrumbs}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}


\subsection{Information and Presentation}

Navigation is only effective if the destination contains the desired
information. We present the commit log, what files were edited, and what
modules were edited at a given commit or merge. Normal tools are unable to
provide information about what files are edited in a merge because they do no
use the tree structure. From our tree structure, we are able to traverse the
subtree, making note of what files are edited and how many lines are added and
removed at every commit.

\evantodo{Picture of files}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{}
\end{figure}

The tree views provide navigation, but are also able to present implied
information about the depth and number of commits in a given merge.

\section{Discussion}

Our search provides mechanisms for users looking for top-down and bottom-up
approaches. In figures \ref{fig:AndrewMortonMerges} and \ref{fig:AndrewMorton}
we see the difference in responses when looking for the merges by Linus and the
commits authored by Andrew Morton.
\evantodo{Picture of results for top-down and bottom-up}

%% http://localhost:8080/search?version=Linux+3.14&commit_date_begin=&commit_date_end=&search-text=Morton&search-type=Author&merges=on

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{fig:AndrewMortonMerges}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.47\textwidth]{figures/empty.png}
	\caption{}
	\label{fig:AndrewMorton}
\end{figure}




\section{Future Work}
We have limited search functionality regarding actual files involved in
commits. If a user knows which file they are working with and what has changed
in a given file, they are unable to look specifically for commits pertaining to
that file. Adding a search filter for searching by file would allow maintainers
to perform this search.

Currently, there are still various features that have bad performance. More
work is required to get those features responding more quickly, or providing an
asynchronous mechanism and loading bars to improve user experience.

At this time, we have no evidence that our tool is able to improve the
work-flow of maintainers. We believe that the tool is able to improve the
work-flow and performance of maintainers because it is able to better assist
users because it provides cleaner mechanisms of working with the data. It is
able to provide more relevant information, while removing information that is
irrelevant to a given module or set of merges.

\end{document}
