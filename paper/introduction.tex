% vim:set et sts=2 sw=2 ts=2 tw=72:
Between 50k and 70k commits are added to the Linux kernel per version
requiring maintainers of older versions of the kernel to sift through
thousands of commits and merges with tools that are unable to filter and
effectively visualize projects at the scale of the kernel. Older
versions of the kernel are used in embedded systems and mobile phones;
for security purposes, performance needs, and changing hardware
requirements, maintainers must be able to understand the changes being
made in the current version of the kernel in order to produce the
necessary patches for the older versions of the kernel. Tools like Gitk
use a directed acyclic graph (DAG) model of the repository, showing all
commits and merges in chronological order by when the commit was
authored, not by when it arrived in the official Linux repository.

\begin{figure*}
        \centering
        \includegraphics[width=0.97\textwidth]{figures/gitk.png}
        \caption{A view of the Gitk interface centered on merge
          b34870fc9ff15fe46c4066faeeec437a4e63e2d8 by Miller. Commits point toward
          their ancestors and there is no clear path from the commit to the merge
          with the master branch. Neither Gitk nor Git are capable of showing the
          commits in master.}
        \label{fig:gitk}
%\vspace{-4mm}
\end{figure*}


\begin{figure}
        \centering
        \includegraphics[width=0.45\textwidth]{figures/github_viewer.png}
        \caption{Github Failure Message showing the DAG of the Linux Project and its
                relationship to other forks.}
        \label{fig:gitfail}
%\vspace{-2mm}
\end{figure}


This representation works in smaller projects; it enables users to see
when changes are made, when these changes are merged, how each branch is
interacting, and the point where a branch forks from the master branch.
In large modular projects, like the Linux kernel, the DAG becomes a mess
of merges and commits (Figure~\ref{fig:gitk}) losing its visual meaning.
In some cases, the Linux kernel is simply too large for the system to
generate a visualization; Github provides a DAG view for many projects,
but is unable to display the visualization for projects at the scale of
the Linux of the kernel (Figure~\ref{fig:gitfail}).  Between 60k and 70k
new commits are created for the Linux project every year; according to
our previous work\cite{German2015}, a commit takes a median of 30 days
from the time it is authored until it arrives in the official
repository. The snapshot of the kernel tomorrow may be different than
the snapshot from today, containing new commits authored in the past;
distinguishing these new commits from the commits in the snapshot from
today is not trivial.


One major challenge with visualizing the arrival of commits to a
repository is that Git does not store the date that a commit was merged
into another branch, including the master branch. To complicate the
problem, the DAG only has references to the ancestors of a commit (a
model necessary for the operation of Git), but maintainers would prefer
knowing the path a commit followed to reach the master repository.
Tracing a path that any commit followed to the master repository would
imply that for any given merge, it would be possible to know which
commits were merged. A user could inspect the commits that arrived into
the master branch within a given time-frame by checking which commits
were merged during that time-frame.

This paper makes two contributions; first, we describe a method of
converting the DAG of the Linux repository into a tree, or
\emph{merge-tree} of the repository, that represents the path used by a
commit to reach the master branch; second, we present a method to
inspect and visualize the history of merges in the Linux project using
the merge-tree model.

These methods and visualizations are implemented in a web-based tool
called \tool\footnote{\tool is currently available at
  \url{http://li.turingmachine.org}}.  Our visualizations and tool
provide information about the location of any given commit or merge in
its respective merge-tree, the files edited, the modules edited, and the
commit message. \tool allows users to apply various filters, including
the release version, along with a keyword or phrase from the log
preview, the name of the author, or the commit ID. The user can request
all merges made by Linus that contain a commit or inner merge that
matches the search query, or just the commits and merges that match the
query.

